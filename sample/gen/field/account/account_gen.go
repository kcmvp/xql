// Code generated by gob xql schema. DO NOT EDIT.
// Generated at: 2026-01-04 22:12:13 (ver: 754218eb7f)

package account

import (
	"github.com/kcmvp/xql"
	. "github.com/kcmvp/xql/sample/entity"
	"github.com/kcmvp/xql/view"
	"time"
)

// AccountFields provides access to the entity's field definitions.
var (
	ID            = xql.NewField[Account, int64]("id", "ID")
	ViewID        = view.WrapField[int64](ID)
	Email         = xql.NewField[Account, string]("email", "Email")
	ViewEmail     = view.WrapField[string](Email)
	Nickname      = xql.NewField[Account, string]("nick_name", "Nickname", xql.MaxLength(100))
	ViewNickname  = view.WrapField[string](Nickname)
	Category      = xql.NewField[Account, int64]("category", "Category")
	ViewCategory  = view.WrapField[int64](Category)
	Balance       = xql.NewField[Account, float64]("balance", "Balance")
	ViewBalance   = view.WrapField[float64](Balance)
	CreatedAt     = xql.NewField[Account, time.Time]("created_at", "CreatedAt")
	ViewCreatedAt = view.WrapField[time.Time](CreatedAt)
	UpdatedAt     = xql.NewField[Account, time.Time]("updated_at", "UpdatedAt")
	ViewUpdatedAt = view.WrapField[time.Time](UpdatedAt)
	CreatedBy     = xql.NewField[Account, string]("created_by", "CreatedBy")
	ViewCreatedBy = view.WrapField[string](CreatedBy)
	UpdatedBy     = xql.NewField[Account, string]("updated_by", "UpdatedBy")
	ViewUpdatedBy = view.WrapField[string](UpdatedBy)
)

// All returns all field definitions for Account in a stable order.
func All() []xql.Field {
	return []xql.Field{
		ID,
		Email,
		Nickname,
		Category,
		Balance,
		CreatedAt,
		UpdatedAt,
		CreatedBy,
		UpdatedBy,
	}
}

// AllExclude returns all field definitions for Account except the provided ones.
//
// Example:
//
//	fields := AllExclude(UpdatedAt, UpdatedBy)
func AllExclude(exclude ...xql.Field) []xql.Field {
	if len(exclude) == 0 {
		return All()
	}

	excluded := make(map[string]struct{}, len(exclude))
	for _, f := range exclude {
		excluded[f.QualifiedName()] = struct{}{}
	}

	all := All()
	out := make([]xql.Field, 0, len(all))
	for _, f := range all {
		if _, ok := excluded[f.QualifiedName()]; ok {
			continue
		}
		out = append(out, f)
	}
	return out
}
